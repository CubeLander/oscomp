# MonkeyOS 行为表单适用性清单（非文件系统类 syscall）

本清单用于评估 **非文件系统类系统调用** 是否适合使用 MonkeyOS 风格的 **控制流对象（如 `proc_context` / `mm_context` 等）** 进行行为抽象和组合处理。

## ✅ 适合抽象的系统调用

这些系统调用具备以下特性中的两项以上：
- 行为组合性强（多步骤）
- 涉及多个系统资源（进程、内存、设备等）
- 存在明确的生命周期管理
- 存在潜在的异步执行或并发调度需求

| 系统调用       | 建议抽象表单类型 | 理由概述 |
|----------------|------------------|---------|
| `execve()`     | `exec_context`   | 涉及路径解析、权限判断、清理资源、加载程序、参数解析；具备完整生命周期转换 |
| `clone()` / `fork()` | `proc_context`    | 涉及任务复制、资源克隆、线程状态创建、PID 分配、调度器通知等组合操作 |
| `waitpid()`    | `proc_context`    | 阻塞-非阻塞行为、僵尸状态处理、信号集成、调度配合等；依赖其他任务状态 |
| `mmap()` / `munmap()` | `mm_context` | 虚拟内存区段管理、页表构建、文件映射、权限控制、地址冲突处理等 |
| `mprotect()`   | `mm_context`      | 动态页权限变更，可能触发缺页中断、页框分配、TLB 刷新 |
| `io_uring_enter()` | `uring_context` | 本身即为行为表单集合，涉及异步提交、依赖跟踪、资源调度；天然 monkey 模型 |
| `poll()` / `select()` | `event_context` | 多资源状态组合、阻塞等待、回调注册、异步派发链；适合作为事件任务图构件 |
| `listen()` / `accept()` | `net_context` | 涉及 socket 状态转换、连接队列、backlog 管理、文件句柄创建等复合行为 |


## ❌ 不建议抽象的系统调用

这些系统调用行为原子、结构简单、没有行为拆分空间：

| 系统调用     | 理由 |
|--------------|------|
| `getpid()`   | 无参数、无状态、无资源依赖 |
| `gettimeofday()` | 直接读系统时钟，无资源无生命周期 |
| `sched_yield()` | 单次 hint 操作，无需行为建模 |
| `brk()`      | 内部处理简单，仅更新任务的 break 指针 |
| `pause()`    | 行为被信号打断即可，无状态构造 |
| `exit()`     | 最终状态提交，无行为组合、不可拆分 |


## 🧠 MonkeyOS 抽象原则小结

> ✅ 是否涉及多个资源？
> ✅ 是否需要组合多个行为？
> ✅ 是否存在生命周期或引用管理？
> ✅ 是否有调度需求（并发/异步）？

满足两个以上，即具备构造行为表单的价值。

---

## 🌱 深度可抽象系统调用的核心复杂性分析

### 🔸 `execve()` - 执行新程序
- ✅ 涉及路径查找（VFS）
- ✅ 涉及文件验证与权限判断
- ✅ 涉及加载器机制（ELF、PIE 等）
- ✅ 涉及用户空间参数布局和环境变量
- ✅ 涉及 mm_struct 重建，原资源清理
→ 具备完整的生命周期切换，适合拆为多步行为表单：`lookup → validate → load → map → replace`

### 🔸 `fork()` / `clone()` - 创建新进程/线程
- ✅ 涉及任务结构复制（task_struct）
- ✅ 涉及资源引用复制（file_table、mm、signal）
- ✅ 涉及 pid 分配、父子关系建立
- ✅ 涉及调度器注册、wakeup
→ 行为组合性强，适合构建 `proc_context`，进行延迟、资源可调式派发

### 🔸 `mmap()` / `mprotect()`
- ✅ 涉及地址冲突处理
- ✅ 涉及页表构建、文件映射或匿名分配
- ✅ 涉及权限检查、lazy map 或 copy-on-write 策略
→ 适合 `mm_context` 控制对象，集成页管理、权限、文件绑定行为

### 🔸 `poll()` / `select()` / `epoll_wait()`
- ✅ 涉及多个文件描述符状态监控
- ✅ 阻塞式/非阻塞式状态、事件分发
- ✅ 文件系统/设备层状态驱动
→ 适合构建 `event_context`，统一管理多个 I/O 源的状态监听与通知行为图

### 🔸 `listen()` / `accept()`
- ✅ 涉及 socket 状态切换（LISTEN、ACCEPT）
- ✅ 涉及连接请求队列管理
- ✅ 涉及描述符生成与绑定
→ 可通过 `net_context` 管理 socket 层控制逻辑，精细建模 TCP 行为链路

---

Lumi 建议的优先支持 monkey-style 抽象系统调用开发顺序：
1. `execve()` → exec_context
2. `clone()` / `fork()` → proc_context
3. `mmap()` / `munmap()` → mm_context
4. `io_uring_enter()` → uring_context
5. `poll()` / `select()` → event_context
6. `listen()` / `accept()` → net_context

你可以将其整合为 MonkeyOS 行为框架的核心调度结构之外的第一批“高价值表单系统”。
