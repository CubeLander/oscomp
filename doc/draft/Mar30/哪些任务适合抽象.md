# MonkeyOS 行为表单适用性清单（非文件系统类 syscall）

本清单用于评估 **非文件系统类系统调用** 是否适合使用 MonkeyOS 风格的 **控制流对象（如 `proc_context` / `mm_context` 等）** 进行行为抽象和组合处理。

## ✅ 适合抽象的系统调用

这些系统调用具备以下特性中的两项以上：
- 行为组合性强（多步骤）
- 涉及多个系统资源（进程、内存、设备等）
- 存在明确的生命周期管理
- 存在潜在的异步执行或并发调度需求

| 系统调用       | 建议抽象表单类型 | 理由概述 |
|----------------|------------------|---------|
| `execve()`     | `exec_context`   | 涉及路径解析、权限判断、清理资源、加载程序、参数解析 |
| `clone()` / `fork()` | `proc_context`    | 涉及任务复制、资源克隆、线程状态创建、PID 分配等 |
| `waitpid()`    | `proc_context`    | 阻塞-非阻塞行为、僵尸状态处理、信号集成等 |
| `mmap()` / `munmap()` | `mm_context` | 虚拟内存区段管理、页表构建、文件映射、保护权限组合 |
| `mprotect()`   | `mm_context`      | 动态页权限管理、可能引发缺页中断重建 |
| `io_uring_enter()` | `uring_context` | 本身即为行为表单提交，天然契合 monkey 模型 |
| `poll()` / `select()` | `event_context` | 多资源状态组合、注册通知、异步处理链 |
| `setitimer()` / `timerfd_*()` | `timer_context` | 定时器行为创建与管理，存在长生命周期与系统事件交互 |
| `sigaction()` / `kill()` | `signal_context` | 信号注册/发送/传递链处理，行为异步且依赖其他 task_struct 状态 |


## ❌ 不建议抽象的系统调用

这些系统调用行为原子、结构简单、没有行为拆分空间：

| 系统调用     | 理由 |
|--------------|------|
| `getpid()`   | 无参数、无状态、无资源依赖 |
| `gettimeofday()` | 直接读系统时钟，无资源无生命周期 |
| `sched_yield()` | 单次 hint 操作，无需行为建模 |
| `brk()`      | 内部处理简单，仅更新任务的 break 指针 |
| `pause()`    | 行为被信号打断即可，无状态构造 |
| `exit()`     | 最终状态提交，无行为组合、不可拆分 |


## 🧠 MonkeyOS 抽象原则小结

> ✅ 是否涉及多个资源？
> ✅ 是否需要组合多个行为？
> ✅ 是否存在生命周期或引用管理？
> ✅ 是否有调度需求（并发/异步）？

满足两个以上，即具备构造行为表单的价值。

---

Lumi 建议的优先支持 monkey-style 抽象系统调用开发顺序：
1. `execve()` → exec_context
2. `clone()` / `fork()` → proc_context
3. `mmap()` / `munmap()` → mm_context
4. `io_uring_enter()` → uring_context
5. `poll()` / `select()` → event_context

你可以将其整合为 MonkeyOS 行为框架的核心调度结构之外的第一批“高价值表单系统”。
